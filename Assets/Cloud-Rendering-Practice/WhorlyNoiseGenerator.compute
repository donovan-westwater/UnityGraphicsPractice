// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float3> CellPoints;
int Resolution;
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    uint count = 0;
    uint stride = 0;
    CellPoints.GetDimensions(count, stride);
    float3 p = float3(id.x / (float)Resolution, id.y / (float)Resolution, 0);
    float minD = 1;
    for (uint i = 0; i < count; i++) {
        float d = length(CellPoints[i] - p);
        minD = min(d,minD);
        float3 offset = float3(0, 0, 0);
        if (CellPoints[i].x > Resolution /2) offset.x = -Resolution;
        else offset.x = Resolution;
        if (CellPoints[i].y > Resolution /2) offset.y = -Resolution;
        else offset.y = Resolution;
        if (CellPoints[i].z > Resolution /2) offset.z = -Resolution;
        else offset.z = Resolution;
        //Compare straight up to the side and then corner
        d = length((CellPoints[i] + float3(0, offset.y, 0))-p);
        minD = min(d, minD);
        d = length((CellPoints[i] + float3(offset.x, 0, 0)) - p);
        minD = min(d, minD);
        d = length((CellPoints[i] + float3(0, 0, offset.z)) - p);
        minD = min(d, minD);
        //Corner cases
        d = length((CellPoints[i] + float3(offset.x, 0, offset.z)) - p);
        minD = min(d, minD);
        d = length((CellPoints[i] + float3(offset.x, offset.y, 0)) - p);
        minD = min(d, minD);
        d = length((CellPoints[i] + float3(0, offset.y, offset.z)) - p);
        minD = min(d, minD);
        d = length((CellPoints[i] + offset) - p);
        minD = min(d, minD);
    }
    Result[id.xy] = float4(1-minD, 1 - minD, 1 - minD, 1 - minD);
}
