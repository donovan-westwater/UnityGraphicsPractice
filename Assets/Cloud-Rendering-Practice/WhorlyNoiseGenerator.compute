// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> Result;
RWStructuredBuffer<float3> CellPoints;
int Resolution;

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    uint count = 0;
    uint stride = 0;
    uint octaves = 8;
    float h = 0.15;
    CellPoints.GetDimensions(count, stride);
    float3 pA = float3(id.x / (float)Resolution, id.y / (float)Resolution, id.z/(float)Resolution);
    float t = 0;
    float minD = 1;
    //Fractual loop or fBm [WIP Currently Doesn't TILE!]
    for (uint o = 0; o < octaves; o++) {
        float f = pow(2.0, o);
        float a = pow(f, -h);
        float3 p = f*pA;
        //Whorly noise section
        minD = 1;
        for (uint i = 0; i < count; i++) {
            float d = length(CellPoints[i] - p);
            minD = min(d,minD);
            float3 offset = float3(0, 0, 0);
            if (CellPoints[i].x > 0.5) offset.x = -1;
            else offset.x = 1;
            if (CellPoints[i].y > 0.5) offset.y = -1;
            else offset.y = 1;
            if (CellPoints[i].z > 0.5) offset.z = -1;
            else offset.z = 1;
            //Compare straight up to the side and then corner
            d = length((CellPoints[i] + float3(0, offset.y, 0))-p);
            minD = min(d, minD);
            d = length((CellPoints[i] + float3(offset.x, 0, 0)) - p);
            minD = min(d, minD);
            d = length((CellPoints[i] + float3(0, 0, offset.z)) - p);
            minD = min(d, minD);
            //Corner cases
            d = length((CellPoints[i] + float3(offset.x, 0, offset.z)) - p);
            minD = min(d, minD);
            d = length((CellPoints[i] + float3(offset.x, offset.y, 0)) - p);
            minD = min(d, minD);
            d = length((CellPoints[i] + float3(0, offset.y, offset.z)) - p);
            minD = min(d, minD);
            d = length((CellPoints[i] + offset) - p);
            minD = min(d, minD);
        }
        t += a*minD;
    }
    t /= 8; //Normalizes t value
    //if (t < .7) t *= 2;
    minD = min(1, t);
    float outD =  1 - minD;
    Result[id.xyz] = float4(outD, outD, outD, outD);
}
